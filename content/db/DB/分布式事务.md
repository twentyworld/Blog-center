---
title: 分布式事务
type: docs
---

# 分布式事务

- [分布式事务](#分布式事务)
  - [事务](#事务)
  - [分布式理论](#分布式理论)
    - [CAP](#cap)
    - [BASE](#base)
  - [分布式事务理论](#分布式事务理论)
    - [2PC](#2pc)
      - [第一阶段](#第一阶段)
      - [第二阶段 正常流程](#第二阶段-正常流程)
      - [第二阶段：提交/执行阶段（异常流程）](#第二阶段提交执行阶段异常流程)
      - [总结](#总结)
    - [3PC](#3pc)
    - [TCC (Try-Confirm-Cancel)](#tcc-try-confirm-cancel)
      - [过程](#过程)
      - [与2PC的区别](#与2pc的区别)
      - [实现TCC需要注意的点](#实现tcc需要注意的点)
      - [事务悬挂 和 空Cancel](#事务悬挂-和-空cancel)
      - [幂等性设计](#幂等性设计)
      - [优缺点](#优缺点)
    - [SAGA模式](#saga模式)
      - [情景模拟](#情景模拟)
      - [SAGA 对于ACID的保证](#saga-对于acid的保证)
      - [和TCC对比](#和tcc对比)
      - [注意事项](#注意事项)
  - [引用](#引用)

## 事务

ACID



## 分布式理论

### CAP



### BASE





## 分布式事务理论

### 2PC

两阶段提交是指**2PC（two-phase commit protocol**）,2pc是一个非常经典的**强一致、中心化的原子提交协议**。这里所说的中心化是指协议中有两类节点：一个是中心化**协调者节点（coordinator）**和**N个参与者节点（partcipant）**。

![分布式事务-2pc](https://raw.githubusercontent.com/twentyworld/knowledge-island/master/image/分布式事务/分布式事务-2pc.png)

第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.

第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。

#### 第一阶段

就是在分布式事务的发起方在向分布式事务协调者（Coordinator）发送请求时，Coordinator首先会分别向参与者（Partcipant）节点A、参与这节点（Partcipant）节点B分别发送**事务预处理请求**，称之为**Prepare**，有些资料也叫"**Vote Request**"。

说的直白点就是问一下这些参与节点"**这件事你们能不能处理成功了**"，此时这些参与者节点一般来说就会打开本地数据库事务，然后开始执行数据库本地事务，但在执行完成后并不会立马提交数据库本地事务，而是先向Coordinator报告说：“我这边可以处理了/我这边不能处理”。

 如果所有的参与这节点都向协调者作了“**Vote Commit**”的反馈的话，那么此时流程就会进入第二个阶段了。

 #### 第二阶段 正常流程

如果所有参与者节点都向协调者报告说“我这边可以处理”，那么此时协调者就会向所有参与者节点发送“**全局提交确认通知（global_commit）**”，即你们都可以进行本地事务提交了，此时参与者节点就会完成自身本地数据库事务的提交，并最终将提交结果回复“ack”消息给Coordinator，然后Coordinator就会向调用方返回分布式事务处理完成的结果。

#### 第二阶段：提交/执行阶段（异常流程）

相反，在第二阶段除了所有的参与者节点都反馈“我这边可以处理了”的情况外，也会有节点反馈说“我这边不能处理”的情况发生，此时参与者节点就会向协调者节点反馈“**Vote_Abort**”的消息。此时**分布式事务协调者节点**就会向所有的参与者节点发起事务回滚的消息（“**global_rollback**”），此时各个参与者节点就会回滚本地事务，释放资源，并且向协调者节点发送“ack”确认消息，协调者节点就会向调用方返回分布式事务处理失败的结果。

#### 总结
总的来说，XA协议比较简单，成本较低，但是其单点问题，以及不能支持高并发(由于同步阻塞)依然是其最大的弱点。

优点：
> 简单，很简单。

缺点：
> 1. **单点问题**， 事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉，会导致参与者收不到提交或回滚的通知，从而导致参与者节点始终处于事务无法完成的中间状态。
> 2. **资源阻塞**， 从流程上我们可以看得出，其最大缺点就在于它的执行过程中间，节点都处于阻塞状态。各个操作数据库的节点此时都占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知进行全局提交，参与者进行本地事务提交后才会释放资源。这样的过程会比较漫长，对性能影响比较大。
> 3. **数据一致性问题**，在二阶段，如果事务协调者的请求不能到达所有事务参与者(网络问题等等)：就会出现有些参与者已经提交数据，而存在部分参与者还在等待结果。

### 3PC

3PC的过程分了三部分：

1. **canCommit**：是否有能力参与这次事务？是，进入下一步骤；否，退出
2. **preCommit**：协调者向参与者发送事务预提交，事务参与者开始执行事务操作，记录：undo、redo日志，发送消息给协调者：好了、好不了了
3. **doCommit**：commit事务 （如果长时间没有收到事务协调者的提交、回滚请求，超时机制：提交数据）

与2PC的比较：
> 本质上没有什么差别，只是在2pc的基础上，给事务参与者加上了超时机制。这个超时机制在一定程度上减缓了单点问题、资源阻塞。实际上，对2PC的缺点没有根本上的解决。说直接点：**就是加上了个兜底策略。这是2PC设计的不严格，并不是3PC的改进。**

### TCC (Try-Confirm-Cancel)
最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。
TCC事务机制相比于上面介绍的XA，解决了其几个缺点:

1. 解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。
2. 同步阻塞:引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。
3. 数据一致性，有了补偿机制之后，由业务活动管理器控制一致性

#### 过程
TCC编程模式本质上也是一种二阶段协议， 所有事务参与方都需要实现try、confirm/cancle接口。

- **Try阶段：**完成所有业务检查（一致性），预留业务资源(准隔离性)。 在这里承载了很大的工作，资源已经被冻结。不会被其他事务占用。
- **Confirm阶段：**确认执行业务操作，不做任何业务检查， 只使用Try阶段预留的业务资源。
- **Cancel阶段：**取消Try阶段预留的业务资源。

![TCC-过程](https://raw.githubusercontent.com/twentyworld/knowledge-island/master/image/分布式事务/TCC-过程.png)

TCC事务处理流程和 2PC 二阶段提交类似，不过 2PC通常都是在跨库的DB层面，而TCC本质就是一个应用层面的2PC。

#### 与2PC的区别

![tcc.vs.xa](https://raw.githubusercontent.com/twentyworld/knowledge-island/master/image/分布式事务/tcc.vs.xa.png)

**XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁。**

XA事务中的两阶段提交内部过程是对开发者屏蔽的。而事务管理器在两阶段提交过程中，从prepare到commit/rollback过程中，资源实际上一直都是被加锁的。如果有其他人需要更新这两条记录，那么就必须等待锁释放。

**TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁。**

TCC中的两阶段提交并没有对开发者完全屏蔽，也就是说从代码层面，开发者是可以感受到两阶段提交的存在。try、confirm/cancel在执行过程中，一般都会开启各自的本地事务，来保证方法内部业务逻辑的ACID特性。其中：

- try过程的本地事务，是保证资源预留的业务逻辑的正确性。
- confirm/cancel执行的本地事务逻辑确认/取消预留资源，以保证最终一致性，也就是所谓的`补偿型事务(Compensation-Based Transactions)`。

由于是多个独立的本地事务，因此不会对资源一直加锁。


#### 实现TCC需要注意的点
1. 只要try阶段能成功，在confirm阶段一定能成功。这一点很重要，
2. 业务数据的可见性，就是在try阶段之后，confirm之前的状态下，如果其他事务需要读取被预留的资源数据，那么处于中间状态的业务数据该如何向用户展示，这是一个需要被考虑到的问题。比如说：用户在购买之前有200余额，第一个事务的try之后，要锁20块钱。如果在confirm阶段报错一直重试阶段，如何向用户显示余额的问题。
3. 业务数据的并发访问控制。


#### 事务悬挂 和 空Cancel

事务悬挂和空cancel是分布式事务场景下比较普遍，对于事务悬挂和空cancel可以在框架层面给出解决方案

![悬挂](https://raw.githubusercontent.com/twentyworld/knowledge-island/master/image/分布式事务/悬挂.jpeg)

***空cancel***: 上游服务对下游服务的try方法进行调用，在此时产生网络抖动等问题，导致try请求超时，上游服务调用cancel方法。此时网络恢复cancel方法先一步到达下游服务,下游服务需要成功执行空的cancel方法。

**事务悬挂:** 上游服务对下游服务的try方法进行调用，在此时产生网络抖动等问题，导致try请求超时，上游服务调用cancel方法。此时网络恢复cancel方法先一步到达下游服务，而try请求姗姗来迟，下游服务在cancel执行完成后执行了try方法。由于cancel已经执行完成，下游服务try方法中锁定的资源无法得到释放。



其中一个方法是在TM中加入一张表，每当 try/confirm/cancel时，都根据TID(事务ID)对表内数据进行检索。(当然，这不是唯一的选择，甚至可能不会最好的选择。仔细探究的话，会发现，这种方式下，是不能完全保证事务悬挂都会被解决掉的。但是依旧不影响我们在线上大规模使用-每天十亿级别)

1. 如果已存在记录，则对记录中的status进行检查，如果status正确则继续执行，否则进入拒绝逻辑。
2. 如果未存在记录，则向表中插入一条记录，存放当前请求的TID、Domain、Status等信息。（如果不存在，就要插入，下面说明）

![防悬挂模型](https://raw.githubusercontent.com/twentyworld/knowledge-island/master/image/分布式事务/防悬挂模型.jpeg)

以空cancel这种方式（cancel请求先到）来举例说明：

1. 如果在库里没有查询到记录，就会在库里面插入一条记录。

   > 这里不能使用直接抛弃这次请求的方式，如果这样的话，后面的try到来了，因为没有记录。就会生成一条记录，会出现数据不一致，或者事务等待的情况出现。

2. 后面收到了try的请求，根据TID是可以查询到请求的，比对请求和查询到的status，会放弃这次请求。

![防悬挂空cancel](https://raw.githubusercontent.com/twentyworld/knowledge-island/master/image/分布式事务/防悬挂空cancel.jpeg)

#### 幂等性设计

幂等性设计与上面的方悬挂使用了类似的算法。就不细说了。也是通过DB的方式，但是使用了UID的方式。

#### 优缺点

优点：

> 解决了上面说的很多问题。
>
> 降低锁粒度，提高吞吐量

缺点：

> 缺点也很明显，会对当前业务改造。需要对业务增加步骤，业务侵入性强。
>
> 实现难度大：需要针对多种不同网络、系统故障实现不同的回滚策略。还需要满足幂等性要求。增加了实现难度。

### SAGA模式

Saga 模式是一种分布式异步事务，保证最终一致性事务，隶属于柔性事务的一种。Saga 事务模型又叫做长时间运行的事务（Long-running-transaction）, 它是由普林斯顿大学的 H.Garcia-Molina 等人提出，它描述的是另外一种在没有两阶段提交的的情况下解决分布式系统中复杂的业务事务问题。

**每个 Saga 由一系列 sub-transaction Ti （子事务、也叫分支事务）组成**，每个 Ti  都有对应的**补偿动作 Ci**，补偿动作用于撤销 Ti 造成的结果。可以看到，和 TCC 相比，Saga 没有“资源预留”动作，它的 Ti 就是直接提交到库。Saga 事务的执行顺序有两种：

1. （**正常情况下，一阶段流程**）T1, T2, T3, ..., Tn
2. （**异常情况下，一阶段 + 补偿流程**）T1, T2, ..., Tj, Cj,..., C2, C1，其中 0 < j <= n

Saga 定义了**两种恢复策略：**

1. **backward recovery，逆序回滚**：即上面提到的第二种执行顺序，其中 j 是发生错误的 sub-transaction，这种做法的效果是撤销掉之前所有成功的 sub-transation，使得整个 Saga 的执行结果撤销。
2. **forward recovery，向前重试**：适用于必须要成功的场景，执行顺序是类似于这样的：T1, T2, ..., Tj (失败), Tj (重试),..., Tn，其中 j 是发生错误的 sub-transaction，该情况下不需要 Ci。

#### 情景模拟

假设我们的服务逻辑架构是这个样子，现在我们的购买逻辑需要调用不同的远程服务完成：

![drawio-(1)](https://raw.githubusercontent.com/twentyworld/knowledge-island/master/image/分布式事务/drawio-(1).svg)

如果钱包服务发现余额不足，那么已经创建的订单该如何取消？

更糟的是，如果库存不足，我们需要回滚用户的扣款与订单，如果之前除了订单与钱包服务，还有其他的一些操作，我们通通都需要回滚。**因为我们需要保证数据的正确性，以及最终状态的一致。**

**解决方案**

基于我们叙述过的 Saga 事务模式，我们将购买逻辑抽象为一个全局事务：globalPurchaseTransaction，我们将三个子服务抽象为三个子事务：createOrder（cancelOrder）、payOrder（rollbackPayment）、deliverProduct（cancelDelivery），其中括号里是三个子事务的补偿方法。

那么，我们理想情况下的业务逻辑应该是：globalPurchaseTransaction 发起全局事务，全局事务顺序调用三个子事务的一阶段方法，**createOrder -> payOrder -> deliverProduct** 后完成业务逻辑；

如果 deliverProduct 出现异常，则回滚流程为：**createOrder -> payOrder -> deliverProduct -> cancelDelivery -> rollbackPayment -> cancelOrder，**流程图如下：

![创建订单 T1扣减余额 T2发货 T3库存不足回滚发货 C3回滚余额 C2取消订单 C1业务逻辑成功](https://raw.githubusercontent.com/twentyworld/knowledge-island/master/image/分布式事务/drawio-(2).svg)


如果创建订单异常，一般情况下，我们期望能够继续重试业务逻辑，而不是直接丢弃订单向用户返回失败，则整个流程应该向前继续重试：

**createOrder（异常） -> createOrder -> payOrder -> deliverProduct，**流程图如下：

![扣减余额 T2重试创建出错业务逻辑成功创建订单 T1发货 T3](https://raw.githubusercontent.com/twentyworld/knowledge-island/master/image/分布式事务/drawio-(3).svg)

#### SAGA 对于ACID的保证

Saga对于ACID的保证和TCC一样：

- 原子性（Atomicity）：正常情况下保证。
- 一致性（Consistency），在某个时间点，会出现A库和B库的数据违反一致性要求的情况，但是最终是一致的。
- 隔离性（Isolation），在某个时间点，A事务能够读到B事务部分提交的结果。
- 持久性（Durability），和本地事务一样，只要commit则数据被持久。

Saga不提供ACID保证，因为原子性和隔离性不能得到满足。原论文描述如下：

>  full atomicity is not provided. That is, sagas may view the partial results of other sagas

通过saga log，saga可以保证一致性和持久性。

>  因为saga事务没有准备阶段，事务没有隔离，如果两个saga事务同时操作同一资源就会遇到我们操作多线程临界资源的的情况。因此会产生更新丢失，脏数据读取等问题。

####  和TCC对比

Saga相比TCC的缺点是缺少预留动作，导致补偿动作的实现比较麻烦：Ti就是commit，比如一个业务是发送邮件，在TCC模式下，先保存草稿（Try）再发送（Confirm），撤销的话直接删除草稿（Cancel）就行了。而Saga则就直接发送邮件了（Ti），如果要撤销则得再发送一份邮件说明撤销（Ci），实现起来有一些麻烦。

如果把上面的发邮件的例子换成：A服务在完成Ti后立即发送Event到ESB（企业服务总线，可以认为是一个消息中间件），下游服务监听到这个Event做自己的一些工作然后再发送Event到ESB，如果A服务执行补偿动作Ci，那么整个补偿动作的层级就很深。

不过没有预留动作也可以认为是优点：

- 有些业务很简单，套用TCC需要修改原来的业务逻辑，而Saga只需要添加一个补偿动作就行了。
- TCC最少通信次数为2n，而Saga为n（n=sub-transaction的数量）。
- 有些第三方服务没有Try接口，TCC模式实现起来就比较tricky了，而Saga则很简单。
- 没有预留动作就意味着不必担心资源释放的问题，异常处理起来也更简单（请对比Saga的恢复策略和TCC的异常处理）。

#### 注意事项

对于服务来说，实现Saga有以下这些要求：

1. **Ti和Ci是幂等的。**
2. **Ci必须是能够成功的，如果无法成功则需要人工介入。**
3. **Ti - Ci和Ci - Ti的执行结果必须是一样的：sub-transaction被撤销了。**

第一点要求Ti和Ci是幂等的，举个例子，假设在执行Ti的时候超时了，此时我们是不知道执行结果的，如果采用forward recovery策略就会再次发送Ti，那么就有可能出现Ti被执行了两次，所以要求Ti幂等。如果采用backward recovery策略就会发送Ci，而如果Ci也超时了，就会尝试再次发送Ci，那么就有可能出现Ci被执行两次，所以要求Ci幂等。

第二点要求Ci必须能够成功，这个很好理解，因为，如果Ci不能执行成功就意味着整个Saga无法完全撤销，这个是不允许的。但总会出现一些特殊情况比如Ci的代码有bug、服务长时间崩溃等，这个时候就需要人工介入了。

第三点乍看起来比较奇怪，举例说明，还是考虑Ti执行超时的场景，我们采用了backward recovery，发送一个Ci，那么就会有三种情况：

1. Ti的请求丢失了，服务之前没有、之后也不会执行Ti
2. Ti在Ci之前执行
3. Ci在Ti之前执行

第1种情况容易处理。对于第2、3种情况，则要求Ti和Ci是可交换的（commutative)，并且其最终结果都是sub-transaction被撤销。


## 引用

> [再有人问你分布式事务，把这篇扔给他][3]
> [6.0 柔性事务 ：TCC两阶段补偿型][4]


[3]:https://juejin.im/post/6844903647197806605
[4]:http://www.tianshouzhi.com/api/tutorials/distributed_transaction/388
