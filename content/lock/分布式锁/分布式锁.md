# 分布式锁

## 背景

随着公司业务增长，应对高并发场景不得不使用分布式集群，为了保证数据的一致性，需要一些技术手段实现包括**分布式事务和分布式锁。**单机情况下的多线程可以共享堆内存，通过在内存中标记变量实现互斥，我们可以使用Java自带的锁来实现互斥，但是在分布式场景下，多个客户端无法共享内存，为了解决数据一致性问题，需要将标记一个变量也就是锁，放在全局的位置来实现互斥，这样就出现了分布式锁。

## 调研

分布式锁是一个分布式环境中的重要原语，用于保证进程间采用互斥的方式操作共享资源。通常分布式锁以SDK的形式被引入到分布式项目中，主要应用于以下两类场景：

提升效率：加锁是为了避免重复处理，防止任务被多个执行者抢占，避免出现大量回滚操作。
高可靠互斥：加锁是为了避免Race Condition导致逻辑错误，分布式场景下对强一致的要求高。

下面分社区与业界两个维度分别介绍。

### 社区调研

**Menagerie**

> Menagerie是一个使用ZooKeeper实现的Java Concurrency Libraries。除了实现分布式锁，Menagerie实现了Java并发包下的大多数功能，例如java.util.concurrent.locks.Condition，java.util.concurrent.BlockingQueue等。Menagerie存在的问题是并发效率不高，例如每次获取锁时都必须先获取ZooKeeper Session，在Menagerie中这是一个synchronized方法。

**Apache Helix**
> Apache Helix是一个基于一致性协议的集群资源管理框架，其中提供了分布式锁功能。与传统的ZooKeeper实现方式相比，Apache Helix更进一步实现了公平的锁获取机制：
> 避免锁饥饿问题，各个节点获取锁的机会均等
> 在节点失效时该节点持有的锁会被剩余节点机会均等地取得
> 有新节点加入时会触发再均衡机制，保证各节点机会均等

### 业界调研
| 公司 | 项目 | 场景| 实现方案 |
| ---- |:--:| :---|:---|
| Netflix | Curator | Curator是ZooKeeper的客户端封装，其分布式锁的实现完全由ZooKeeper完成。 | 在ZooKeeper创建EPHEMERAL_SEQUENTIAL节点视为加锁，节点的EPHEMERAL特性保证了锁持有者与ZooKeeper断开时强制释放锁；节点的SEQUENTIAL特性避免了加锁较多时的惊群效应。|
| Google | Chubby | Chubby是一套分布式协调系统，内部使用Paxos协调Master与Replicas。 Chubby lock service被应用在GFS，BigTable等项目中，其首要设计目标是高可靠性，而不是高性能。Chubby被作为粗粒度锁使用，例如被用于选主。持有锁的时间跨度一般为小时或天，而不是秒级。 | Chubby对外提供类似于文件系统的API，在Chubby创建文件路径即加锁操作。Chubby使用Delay和SequenceNumber来优化锁机制。Delay保证客户端异常释放锁时，Chubby仍认为该客户端一直持有锁。Sequence number 指锁的持有者向Chubby服务端请求一个序号（包括几个属性），然后之后在需要使用锁的时候将该序号一并发给 Chubby 服务器，服务端检查序号的合法性，包括 number 是否有效等。 |
| 蚂蚁金服 | SOFAJRaft-RheaKV 分布式锁 | RheaKV 是基于 SOFAJRaft 和 RocksDB 实现的嵌入式、分布式、高可用、强一致的 KV 存储类库。 | RheaKV对外提供lock接口，为了优化数据的读写，按不同的存储类型，提供不同的锁特性。RheaKV提供wathcdog调度器来控制锁的自动续租机制，避免锁在任务完成前提前释放，和锁永不释放造成死锁。 |
| 京东 | SharkLock | SharkLock是基于Redis实现的分布式锁。 | 锁的排他性由SETNX原语实现，使用timeout与续租机制实现锁的强制释放。 |

横向对比上述方案，为了实现分布式锁需要解决两个核心问题：

- 保证锁的排他性，即同一个锁在被持有的时间段内只能被一个使用者持有
- 锁超时机制，保证持有锁的线程出现异常时（例如Client失效，宕机等），锁不会被永久占用


## 实现方式

 也可以由业界的实现大致推算出三种实现分布式锁的机制：

- 基于KV存储方式
- 基于分布式一致性算法
- 基于数据库

先说结论，目前大范围使用的实现方式有：基于分布式一致性算法实现的方式、基于KV存储方式。benchmark测试的结果(个人测试，机器什么的都不列举了，做个参考就行)
- zookeeper相对比较稳定，qps在2k-3k左右
- redis性能较高，但是稳定性相对zk低，qps在3.5w



### 基于数据库实现
基于数据库的方式有两种不同的解决方案。

#### 基于数据库表方式实现
要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。

```SQL
CREATE TABLE `methodLock` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `method_name` varchar(64) NOT NULL DEFAULT '' COMMENT '锁定的方法名',
  `desc` varchar(1024) NOT NULL DEFAULT '备注信息',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '保存数据时间，自动生成',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uidx_method_name` (`method_name `) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='锁定中的方法';
```

当我们想要锁住某个资源时（在这里是锁住一个方法），执行以下SQL:
```SQL
insert into methodLock(method_name, desc) values (‘method_name’,‘desc’)
```

因为我们对method_name做了**唯一性约束**，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。

当方法执行完毕之后，想要释放锁的话，需要执行以下SQL:
```SQL
delete from methodLock where method_name ='method_name'
```

这种方式, 显而易见, 很简单也可以快速响应。但是也有很多的问题：
- **单点问题**：这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用
- **锁超时问题**：这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。
- **非阻塞操作**：这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。
- **非重入锁**：这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。

如果我们就是要用基于数据库的方式实现分布式锁呢，当然，也是有解决办法一个一个去解决上面的问题：
- 单点问题就加入备库，做双向同步。
- 需要失效时间，就加上一个定时任务，批量扫描。
- 想要阻塞，while((insert *) ==1 ), 循环插入
- 想要重入，在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的Â时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。

但是.... 也能很容易的看到这些解决方案都不是那么的完美，甚至都可以成 降级策略了
> - 双向同步存在延时问题，
> - 分布式锁的业务可能不会接受这种延迟
> - 批量扫描存在延迟问题；循环有点扯；数据库表家字段表明
> - 重入不是原子操作... 这里面的问题就大了

#### 基于数据库排他锁

除了可以通过增删操作数据表中的记录以外，其实还可以借助数据中自带的锁来实现分布式的锁。

我们还用刚刚创建的那张数据库表。可以通过数据库的排他锁来实现分布式锁。 基于MySql的InnoDB引擎，可以使用以下方法来实现加锁操作：

```Java
  public boolean lock() {
      connection.setAutoCommit(false)
      while(true){
          try{
              result = select * from methodLock where method_name=xxx for update;
              if(result==null){
                  return true;
              }
          }catch(Exception e){

          }
          sleep(1000);
      }
      return false;
  }
```

在查询语句后面增加for update，数据库会在查询过程中给数据库表增加排他锁（这里再多提一句，InnoDB引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给method_name添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上）。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。

我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁：

``` Java

public void unlock(){
    connection.commit();
}

```

通过 connection.commit() 操作来释放锁。

这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。

阻塞锁？ for update语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。

锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。

但是还是无法直接解决数据库单点和可重入问题。

这里还可能存在另外一个问题，虽然我们对method_name 使用了唯一索引，并且显示使用for update来使用行级锁。但是，MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。

### 基于redis的实现方式

主要看这篇文章就够了：
小米信息部技术团队编写的文章 [分布式锁的实现之 redis 篇](https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/)

### 基于Zookeeper实现分布式
基于zookeeper临时有序节点可以实现的分布式锁。

大致思想即为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。

来看下Zookeeper能不能解决前面提到的问题：

- 锁无法释放？使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。
- 非阻塞锁？使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。
- 不可重入？使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。

使用ZK实现的分布式锁好像完全符合了本文开头我们对一个分布式锁的所有期望。但是，其实并不是，Zookeeper实现的分布式锁其实存在一个缺点，那就是性能上可能并没有缓存服务那么高。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上。

其实，使用Zookeeper也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题。这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。（所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。）
